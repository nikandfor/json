package jq_test

import (
	"encoding/base64"
	"fmt"

	"github.com/nikandfor/json/jq"
)

func ExampleSelector() {
	data := []byte(`{"key0":"skip it", "key1": {"next_key": ["array", null, {"obj":"val"}, "trailing element"]}}  "next"`)

	f := jq.Selector{"key1", "next_key", 2} // string keys and int array indexes are supported

	var res []byte // reusable buffer
	var i int      // start index

	// Most filters only parse single value and return index where the value ended.
	// Use jq.ApplyToAll(f, res[:0], data, 0) to process all values in a buffer.
	res, i, err := f.Apply(res[:0], data, i)
	if err != nil {
		// i is an index in a source buffer where the error occured.
	}

	fmt.Printf("value: %s", res)                           // res ends on newline
	fmt.Printf("final position: %d of %d\n", i, len(data)) // object was parsed to the end to be able to read next
	_ = data                                               // but not the next value

	// Output:
	// value: {"obj":"val"}
	// final position: 92 of 100
}

func ExampleBase64d() {
	// generated by command
	// jq -nc '{key3: "value"} | {key2: (. | tojson)} | @base64 | {key1: .}'
	data := []byte(`{"key1":"eyJrZXkyIjoie1wia2V5M1wiOlwidmFsdWVcIn0ifQ=="}`)

	f := jq.NewPipe(
		jq.Selector{"key1"},
		&jq.Base64d{
			Encoding: base64.StdEncoding,
		},
		&jq.JSONDecoder{},
		jq.Selector{"key2"},
		&jq.JSONDecoder{},
		jq.Selector{"key3"},
	)

	res, _, err := f.Apply(nil, data, 0)
	if err != nil {
		panic(err)
	}

	fmt.Printf("%s", res)

	// Output:
	// "value"
}
